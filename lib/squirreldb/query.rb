# SquirrelDB Ruby SDK - Query Builder
# Generated by sdk-generator v0.1.0
# DO NOT EDIT MANUALLY

# frozen_string_literal: true

require "json"

module SquirrelDB
  # Sort direction constants
  module SortDirection
    ASC = "asc"
    DESC = "desc"
  end

  # A single filter condition
  class FilterCondition
    attr_reader :field, :operator, :value

    def initialize(field, operator, value)
      @field = field
      @operator = operator
      @value = value
    end

    def to_h
      { field: @field, operator: @operator, value: @value }
    end
  end

  # Sort specification for a field
  class SortSpec
    attr_reader :field, :direction

    def initialize(field, direction = SortDirection::ASC)
      @field = field
      @direction = direction
    end

    def to_h
      { field: @field, direction: @direction }
    end
  end

  # Options for change subscriptions
  class ChangesOptions
    attr_reader :include_initial

    def initialize(include_initial: true)
      @include_initial = include_initial
    end

    def to_h
      { includeInitial: @include_initial }
    end
  end

  # Field expression for building filter conditions
  class FieldExpr
    def initialize(field_name)
      @field_name = field_name
    end

    # Equal to
    def eq(value)
      FilterCondition.new(@field_name, "$eq", value)
    end

    # Not equal to
    def ne(value)
      FilterCondition.new(@field_name, "$ne", value)
    end

    # Greater than
    def gt(value)
      FilterCondition.new(@field_name, "$gt", value)
    end

    # Greater than or equal to
    def gte(value)
      FilterCondition.new(@field_name, "$gte", value)
    end

    # Less than
    def lt(value)
      FilterCondition.new(@field_name, "$lt", value)
    end

    # Less than or equal to
    def lte(value)
      FilterCondition.new(@field_name, "$lte", value)
    end

    # Value in array
    def in(values)
      FilterCondition.new(@field_name, "$in", values)
    end

    # Value not in array
    def not_in(values)
      FilterCondition.new(@field_name, "$nin", values)
    end

    # String contains substring
    def contains(value)
      FilterCondition.new(@field_name, "$contains", value)
    end

    # String starts with prefix
    def starts_with(value)
      FilterCondition.new(@field_name, "$startsWith", value)
    end

    # String ends with suffix
    def ends_with(value)
      FilterCondition.new(@field_name, "$endsWith", value)
    end

    # Field exists (or not)
    def exists(value = true)
      FilterCondition.new(@field_name, "$exists", value)
    end
  end

  # Document proxy for fluent field access
  class DocProxy
    def method_missing(name, *_args)
      FieldExpr.new(name.to_s)
    end

    def respond_to_missing?(_name, _include_private = false)
      true
    end
  end

  # Query builder for constructing SquirrelDB queries
  class QueryBuilder
    def initialize(table_name)
      @table_name = table_name
      @filters = []
      @sorts = []
      @limit_value = nil
      @skip_value = nil
      @changes_opts = nil
    end

    # Add filter conditions using block or object
    def find(condition = nil, &block)
      if block_given?
        result = block.call(DocProxy.new)
        if result.is_a?(Array)
          @filters.concat(result)
        else
          @filters << result
        end
      elsif condition.is_a?(Array)
        @filters.concat(condition)
      elsif condition
        @filters << condition
      end
      self
    end

    # Add sort specification
    def sort(field_name, direction = SortDirection::ASC)
      @sorts << SortSpec.new(field_name, direction)
      self
    end

    # Set maximum number of results
    def limit(n)
      @limit_value = n
      self
    end

    # Set number of results to skip
    def skip(n)
      @skip_value = n
      self
    end

    # Subscribe to changes
    def changes(options = nil)
      @changes_opts = options || ChangesOptions.new
      self
    end

    # Compile to structured query object
    def compile_structured
      query = { table: @table_name }

      query[:filter] = build_filter_object unless @filters.empty?
      query[:sort] = @sorts.map(&:to_h) unless @sorts.empty?
      query[:limit] = @limit_value if @limit_value
      query[:skip] = @skip_value if @skip_value
      query[:changes] = @changes_opts.to_h if @changes_opts

      query
    end

    # Compile to JSON string
    def compile
      JSON.generate(compile_structured)
    end

    private

    def build_filter_object
      filter_obj = {}
      @filters.each do |cond|
        filter_obj[cond.field] ||= {}
        filter_obj[cond.field][cond.operator] = cond.value
      end
      filter_obj
    end
  end

  # Create a new query builder for a table
  def self.table(name)
    QueryBuilder.new(name)
  end

  # Create a field expression for filtering
  def self.field(name)
    FieldExpr.new(name)
  end

  # Combine conditions with AND
  def self.and(*conditions)
    FilterCondition.new("$and", "$and", conditions.map(&:to_h))
  end

  # Combine conditions with OR
  def self.or(*conditions)
    FilterCondition.new("$or", "$or", conditions.map(&:to_h))
  end

  # Negate a condition
  def self.not(condition)
    FilterCondition.new("$not", "$not", condition.to_h)
  end
end

# SquirrelDB Ruby SDK - Cache (Redis-compatible)
# Generated by sdk-generator v0.1.0
# DO NOT EDIT MANUALLY

# frozen_string_literal: true

require "socket"

module SquirrelDB
  # Redis-compatible cache client using RESP protocol
  class Cache
    class Error < StandardError; end

    def initialize(host: "localhost", port: 6379)
      @host = host
      @port = port
      @socket = nil
    end

    def self.connect(host: "localhost", port: 6379)
      cache = new(host: host, port: port)
      cache.send(:do_connect)
      cache
    end

    def get(key)
      resp = command("GET", key)
      resp.is_a?(NilClass) ? nil : resp
    end

    def set(key, value, ttl: nil)
      if ttl
        command("SET", key, value, "EX", ttl.to_s)
      else
        command("SET", key, value)
      end
      true
    end

    def del(key)
      command("DEL", key) > 0
    end

    def exists(key)
      command("EXISTS", key) > 0
    end

    def expire(key, seconds)
      command("EXPIRE", key, seconds.to_s) > 0
    end

    def ttl(key)
      command("TTL", key)
    end

    def incr(key)
      command("INCR", key)
    end

    def decr(key)
      command("DECR", key)
    end

    def incrby(key, amount)
      command("INCRBY", key, amount.to_s)
    end

    def decrby(key, amount)
      command("DECRBY", key, amount.to_s)
    end

    def mget(*keys)
      command("MGET", *keys)
    end

    def mset(hash)
      args = hash.flat_map { |k, v| [k.to_s, v.to_s] }
      command("MSET", *args)
      true
    end

    def keys(pattern = "*")
      command("KEYS", pattern)
    end

    def dbsize
      command("DBSIZE")
    end

    def flushdb
      command("FLUSHDB")
      true
    end

    def info
      result = command("INFO")
      result.split("\n").reject { |l| l.empty? || l.start_with?("#") }.map do |line|
        line.split(":", 2)
      end.to_h
    end

    def ping
      command("PING") == "PONG"
    end

    def close
      command("QUIT") rescue nil
      @socket&.close
      @socket = nil
    end

    private

    def do_connect
      @socket = TCPSocket.new(@host, @port)
    end

    def command(*args)
      raise Error, "Not connected" unless @socket

      @socket.write(encode_command(args))
      read_response
    end

    def encode_command(args)
      parts = ["*#{args.length}\r\n"]
      args.each do |arg|
        arg = arg.to_s
        parts << "$#{arg.bytesize}\r\n#{arg}\r\n"
      end
      parts.join
    end

    def read_response
      line = @socket.gets.chomp
      prefix = line[0]
      content = line[1..]

      case prefix
      when "+"
        content
      when "-"
        raise Error, content
      when ":"
        content.to_i
      when "$"
        len = content.to_i
        return nil if len == -1

        data = @socket.read(len)
        @socket.read(2) # Read \r\n
        data
      when "*"
        count = content.to_i
        return nil if count == -1

        count.times.map { read_response }
      else
        raise Error, "Unknown RESP type: #{prefix}"
      end
    end
  end
end

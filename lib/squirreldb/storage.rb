# SquirrelDB Ruby SDK - Storage (S3-compatible)
# Generated by sdk-generator v0.1.0
# DO NOT EDIT MANUALLY

# frozen_string_literal: true

require "net/http"
require "uri"
require "openssl"
require "time"
require "rexml/document"

module SquirrelDB
  # S3-compatible storage client
  class Storage
    class Error < StandardError
      attr_reader :status_code

      def initialize(message, status_code = nil)
        super(message)
        @status_code = status_code
      end
    end

    Bucket = Struct.new(:name, :created_at, keyword_init: true)
    StorageObject = Struct.new(:key, :size, :etag, :last_modified, keyword_init: true)

    def initialize(endpoint:, access_key: nil, secret_key: nil, region: "us-east-1")
      @endpoint = endpoint.chomp("/")
      @access_key = access_key
      @secret_key = secret_key
      @region = region
    end

    def list_buckets
      response = request("GET", "/")
      doc = REXML::Document.new(response.body)
      doc.elements.collect("//Bucket/Name") do |e|
        Bucket.new(name: e.text, created_at: Time.now)
      end
    end

    def create_bucket(name)
      request("PUT", "/#{name}")
      true
    end

    def delete_bucket(name)
      request("DELETE", "/#{name}")
      true
    end

    def bucket_exists?(name)
      request("HEAD", "/#{name}")
      true
    rescue Error
      false
    end

    def list_objects(bucket, prefix: nil, max_keys: nil)
      path = "/#{bucket}"
      params = []
      params << "prefix=#{URI.encode_www_form_component(prefix)}" if prefix
      params << "max-keys=#{max_keys}" if max_keys
      path += "?#{params.join("&")}" unless params.empty?

      response = request("GET", path)
      doc = REXML::Document.new(response.body)

      doc.elements.collect("//Contents") do |e|
        StorageObject.new(
          key: e.elements["Key"]&.text,
          size: e.elements["Size"]&.text&.to_i || 0,
          etag: e.elements["ETag"]&.text&.gsub('"', ""),
          last_modified: Time.now
        )
      end
    end

    def get_object(bucket, key)
      response = request("GET", "/#{bucket}/#{key}")
      response.body
    end

    def put_object(bucket, key, data, content_type: "application/octet-stream")
      headers = { "Content-Type" => content_type }
      response = request("PUT", "/#{bucket}/#{key}", body: data, headers: headers)
      response["etag"]&.gsub('"', "") || ""
    end

    def delete_object(bucket, key)
      request("DELETE", "/#{bucket}/#{key}")
      true
    end

    def object_exists?(bucket, key)
      request("HEAD", "/#{bucket}/#{key}")
      true
    rescue Error
      false
    end

    private

    def request(method, path, body: nil, headers: {})
      uri = URI.parse("#{@endpoint}#{path}")
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == "https"

      request_class = {
        "GET" => Net::HTTP::Get,
        "PUT" => Net::HTTP::Put,
        "DELETE" => Net::HTTP::Delete,
        "HEAD" => Net::HTTP::Head
      }[method]

      req = request_class.new(uri)
      headers.each { |k, v| req[k] = v }
      req.body = body if body

      if @access_key && @secret_key
        sign_request(req, uri, body)
      end

      response = http.request(req)

      unless response.is_a?(Net::HTTPSuccess) || response.is_a?(Net::HTTPNoContent)
        raise Error.new(response.body, response.code.to_i)
      end

      response
    end

    def sign_request(req, uri, body)
      now = Time.now.utc
      date_stamp = now.strftime("%Y%m%d")
      amz_date = now.strftime("%Y%m%dT%H%M%SZ")

      payload_hash = OpenSSL::Digest::SHA256.hexdigest(body || "")
      req["x-amz-date"] = amz_date
      req["x-amz-content-sha256"] = payload_hash

      signed_headers = (req.to_hash.keys + ["host"]).sort.join(";")
      canonical_headers = (req.to_hash.merge("host" => [uri.host])).sort.map { |k, v| "#{k}:#{v.join(",")}\n" }.join

      canonical_request = [
        req.method,
        uri.path,
        uri.query || "",
        canonical_headers,
        signed_headers,
        payload_hash
      ].join("\n")

      algorithm = "AWS4-HMAC-SHA256"
      credential_scope = "#{date_stamp}/#{@region}/s3/aws4_request"
      string_to_sign = [
        algorithm,
        amz_date,
        credential_scope,
        OpenSSL::Digest::SHA256.hexdigest(canonical_request)
      ].join("\n")

      k_date = hmac_sha256("AWS4#{@secret_key}", date_stamp)
      k_region = hmac_sha256(k_date, @region)
      k_service = hmac_sha256(k_region, "s3")
      k_signing = hmac_sha256(k_service, "aws4_request")
      signature = OpenSSL::HMAC.hexdigest("SHA256", k_signing, string_to_sign)

      req["Authorization"] = "#{algorithm} Credential=#{@access_key}/#{credential_scope}, SignedHeaders=#{signed_headers}, Signature=#{signature}"
    end

    def hmac_sha256(key, data)
      OpenSSL::HMAC.digest("SHA256", key, data)
    end
  end
end
